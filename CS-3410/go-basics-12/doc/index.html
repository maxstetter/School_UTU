<html><head></head><body><h1>Instructions</h1>

<p>A circular buffer, cyclic buffer or ring buffer is a data structure that
uses a single, fixed-size buffer as if it were connected end-to-end.</p>

<p>A circular buffer first starts empty and of some predefined length. For
example, this is a 7-element buffer:</p>

<pre><code>[ ][ ][ ][ ][ ][ ][ ]
</code></pre>

<p>Assume that a 1 is written into the middle of the buffer (exact starting
location does not matter in a circular buffer):</p>

<pre><code>[ ][ ][ ][1][ ][ ][ ]
</code></pre>

<p>Then assume that two more elements are added — 2 &amp; 3 — which get
appended after the 1:</p>

<pre><code>[ ][ ][ ][1][2][3][ ]
</code></pre>

<p>If two elements are then removed from the buffer, the oldest values
inside the buffer are removed. The two elements removed, in this case,
are 1 &amp; 2, leaving the buffer with just a 3:</p>

<pre><code>[ ][ ][ ][ ][ ][3][ ]
</code></pre>

<p>If the buffer has 7 elements then it is completely full:</p>

<pre><code>[5][6][7][8][9][3][4]
</code></pre>

<p>When the buffer is full an error will be raised, alerting the client
that further writes are blocked until a slot becomes free.</p>

<p>When the buffer is full, the client can opt to overwrite the oldest
data with a forced write. In this case, two more elements — A &amp; B —
are added and they overwrite the 3 &amp; 4:</p>

<pre><code>[5][6][7][8][9][A][B]
</code></pre>

<p>3 &amp; 4 have been replaced by A &amp; B making 5 now the oldest data in the
buffer. Finally, if two elements are removed then what would be
returned is 5 &amp; 6 yielding the buffer:</p>

<pre><code>[ ][ ][7][8][9][A][B]
</code></pre>

<p>Because there is space available, if the client again uses overwrite
to store C &amp; D then the space where 5 &amp; 6 were stored previously will
be used not the location of 7 &amp; 8. 7 is still the oldest element and
the buffer is once again full.</p>

<pre><code>[C][D][7][8][9][A][B]
</code></pre>
</body></html>